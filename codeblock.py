# -*- coding: utf-8 -*-
"""CodeBlock

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T5FLnxz2N7_ZpRK9dy5doXJOteNbBZBM

2020

Infinite Loop: password que
"""

digit="1234567890"
lc="abcdefghijklmnopqrstuvwxyz"
uc="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
sc="!@#$%^&*()-+"

digi=[]
for di in digit:
 digi.append(di)

upper=[]
for u in uc:
 upper.append(u)

lower=[]
for l in lc:
  lower.append(l)

special=[]
for s in sc:
  special.append(s)

no=int(input("No of Char"))
password=input("Password")

pswd=[]
for pas in password:
  pswd.append(pas)

cnt=0
cnt2=0
for a in pswd:
  for b in digi:
   if a==b:
     cnt2=+1
   else:
    cnt+=1

for a in pswd:
  for c in upper:
   if a==c:
     cnt2+=1
   else:
    cnt+=1

for a in pswd:
  for d in lower:
   if a==d:
     cnt2+=1
   else:
    cnt+=1

for a in pswd:
  for e in special:
   if a==e:
     cnt2+=1
   else:
    cnt+=1
 
list=[]
list.append(no)
list.append(password)

no2=0
if (no<6):
    no2=6-no;
    cnt=cnt+no2


print(cnt)

"""Coursera Python course:"""

def calculator(somedata):                 # calculator function, 'somedata' is the input
    blocksize = 4096                      # what block size on the partition
                                          # calculate how many blocks are fully occupied
    fullblock = somedata // blocksize     # floor division will give back only the integer yes?
                                          # modulo to check whether there's any remainder
    bytesremain = somedata % blocksize    # which will say 1 or None unless I float yes?
                                          # return the block usage based on byte count?
    if bytesremain > 0:                   # if there's anything left over in the bytesremain
      return(blocksize * 2)               # double the block usage to 2
    return blocksize                      # otherwise return the block usage

print(calculator(1))                      # Should be 4096 
print(calculator(4096))                   # Should be 4096 
print(calculator(4097))                   # Should be 8192 
print(calculator(6000))

def calculate_storage(filesize):
    block_size = 4096

    # Use floor division to calculate how many blocks are fully occupied
    full_blocks = filesize//block_size

    # Use the modulo operator to check whether there's any remainder
    partial_block_remainder = filesize%block_size

    # Depending on whether there's a remainder or not, return
    # the total number of bytes required to allocate enough blocks
    # to store your data.
    if partial_block_remainder > 0:
        return (full_blocks*4096)+4096
    return (full_blocks*4096)

print(calculate_storage(1))    # Should be 4096
print(calculate_storage(4096)) # Should be 4096
print(calculate_storage(4097)) # Should be 8192
print(calculate_storage(6000)) # Should be 8192

"small"<"big"

def sum(x, y):
		return(x+y)
print(sum(sum(1,2), sum(3,4)))
((10 >= 5*2) and (10 <= 5*2))

def factorial(n):
    result = 1
    for i in range(1,n+1):
        result=result*i
    return result

print(factorial(4)) # should return 24
print(factorial(5)) # should return 120

"""Recursion function"""

def factorial(n):
  if n<2:
    return 1
  return n*factorial(n-1)

factorial(4)

for x in range(1, 10, 3):
    print(x)

for x in range(10):
    for y in range(x):
        print(y)

go for someone who is proud to have you.

#include<stdio.h>
void main()
{
 float salary, hra, ta;
 printf("Enter your base salary: ");
 scanf("%f",&salary);
 hra = (salary*10)/100;
 ta = (salary*5)/100;
 printf("\nTotal salary = Rs. %.2f",salary+hra+ta);
}

def get_event_date(event):
    return event.date

def current_users(events):
    events.sort(key=get_event_date)
    machines = {}
    for event in events:
        if event.machine not in machines:
            machines[event.machine] = set()
        if event.type == "login":
            machines[event.machine].add(event.user)
        elif event.type == "logout":
            machines[event.machine].remove(event.user)
    return machines

def generate_report(machines):
    for machine, users in machines.items():
        if len(users) > 0:
            user_list = ", ".join(users)
            print("{}: {}".format(machine, user_list))

def get_event_date(event):
    return event.date

def current_users(events):
    events.sort(key=get_event_date)
    machines = {}
    for event in events:
        if event.machine not in machines:
            machines[event.machine] = set()
        if event.type == "login":
            machines[event.machine].add(event.user)
        elif event.type == "logout" and event.user in machines[event.machine]:
            machines[event.machine].remove(event.user)
    return machines

def generate_report(machines):
    for machine, users in machines.items():
        if len(users) > 0:
            user_list = ", ".join(users)
        print("{}: {}".format(machine, user_list))

def calculate_frequencies(file_contents):
    # Here is a list of punctuations and uninteresting words you can use to process your text
    punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
    uninteresting_words = ["the", "a", "to", "if", "is", "it", "of", "and", "or", "an", "as", "i", "me", "my", \
    "we", "our", "ours", "you", "your", "yours", "he", "she", "him", "his", "her", "hers", "its", "they", "them", \
    "their", "what", "which", "who", "whom", "this", "that", "am", "are", "was", "were", "be", "been", "being", \
    "have", "has", "had", "do", "does", "did", "but", "at", "by", "with", "from", "here", "when", "where", "how", \
    "all", "any", "both", "each", "few", "more", "some", "such", "no", "nor", "too", "very", "can", "will", "just"]
    
    # LEARNER CODE START HERE
    frequencies =  {}
    taken = []
    for letter in punctuations:
        file_contents =  file_contents.replace(letter,'')
    for word in uninteresting_words:
        w = ' '+word+' '
        file_contents = file_contents.replace(w,' ')
    for word in file_contents.split():
        if word.lower() not in taken:
            taken.append(word.lower())
            if word not in frequencies:
                frequencies[word] = 1
            else:
                frequencies[word] += 1
    #wordcloud
    cloud = wordcloud.WordCloud()
    cloud.generate_from_frequencies()
    return cloud.to_array()

def calculate_frequencies(file_contents):
    # Here is a list of punctuations and uninteresting words you can use to process your text
    punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~"'''
    uninteresting_words = ["the", "a", "to", "if", "is", "in" "it", "of", "and", "or","on", "an", "as", "i", "me", "my", \
    "we", "our", "ours", "you", "your", "yours", "he", "she", "him", "his", "her", "hers", "its", "they", "them", \
    "their", "what", "which", "who", "whom", "this", "that", "am", "are", "was", "were", "be", "been", "being", \
    "have", "has", "had", "do", "does", "did", "but", "at", "by", "with", "from", "here", "when", "where", "how", \
    "all", "any", "both", "each", "few", "more", "some", "such", "no", "nor", "too", "very", "can", "will", "just"]
    
    # LEARNER CODE START HERE
    frequencies =  {}
    taken = []
    for letter in punctuations:
        file_contents =  file_contents.replace(letter,'')
    for word in uninteresting_words:
        w = ' '+word+' '
        file_contents = file_contents.replace(w,' ')
    for word in file_contents.split():
        if word.lower() not in taken:
            taken.append(word.lower())
            if word not in frequencies:
                frequencies[word] = 1
            else:
                frequencies[word] += 1
          
    
    #wordcloud
    cloud = wordcloud.WordCloud()
    cloud.generate_from_frequencies(frequencies)
    return cloud.to_array()

"""Demux"""

class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        int n= arr.size(), i, c=1;
        
        for(i=1;i<n;i++)
        {
            if (arr[i]==arr[i-1])
                c++;
            else
            {
                if (c>n/4)
                    return arr[i-1];
                else
                    c=1;
            }
        }
        if (c>n/4)
            return arr[i];
        
        return -1;
    }
    
};

class Solution {
public:
    int findSpecialInteger(vector<int>& ar) {
        int n = ar.size(), i, c = 1;
       
        for(i = 1; i < n; i++){
            if(ar[i] == ar[i-1])
                c++;
            else{
                if(c > n/4)
                    return ar[i-1];
                else
                    c = 1;
            }
        }
       
        if(c > n/4)
            return ar[n-1];
       
        // Control never reaches here
        return -1;
    }
};

def repeat(arr):
    n=0
    c=1
    count = []
    for i in range(0,len(arr)-1):
        if arr[i]==arr[i+1]:
            c += 1
        else:
            c = 1
        count.append(c)
    print(max(count))


arr = list(input())
repeat(arr)